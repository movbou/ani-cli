#!/bin/sh

version_number="4.10.4-videa"

# UI

external_menu() {
    rofi "$1" -sort -dmenu -i -width 1500 -p "$2" "$3"
}

launcher() {
    [ "$use_external_menu" = "0" ] && [ -z "$1" ] && set -- "+m" "$2"
    [ "$use_external_menu" = "0" ] && fzf "$1" --reverse --cycle --prompt "$2"
    [ "$use_external_menu" = "1" ] && external_menu "$1" "$2" "$external_menu_args"
}

nth() {
    stdin=$(cat -)
    [ -z "$stdin" ] && return 1
    line_count="$(printf "%s\n" "$stdin" | wc -l | tr -d "[:space:]")"
    [ "$line_count" -eq 1 ] && printf "%s" "$stdin" | cut -f2,3 && return 0
    prompt="$1"
    multi_flag=""
    [ $# -ne 1 ] && shift && multi_flag="$1"
    line=$(printf "%s" "$stdin" | cut -f1,3 | tr '\t' ' ' | launcher "$multi_flag" "$prompt" | cut -d " " -f 1)
    line_start=$(printf "%s" "$line" | head -n1)
    line_end=$(printf "%s" "$line" | tail -n1)
    [ -n "$line" ] || exit 1
    if [ "$line_start" = "$line_end" ]; then
        printf "%s" "$stdin" | grep -E '^'"${line}"'($|[[:space:]])' | cut -f2,3 || exit 1
    else
        printf "%s" "$stdin" | sed -n '/^'"${line_start}"'$/,/^'"${line_end}$"'/p' || exit 1
    fi
}

die() {
    printf "\33[2K\r\033[1;31m%s\033[0m\n" "$*" >&2
    exit 1
}

help_info() {
    printf "
    Usage:
    %s [options] [query]
    %s [query] [options]
    %s [options] [query] [options]

    Options:
      -c, --continue
        Continue watching from history
      -d, --download
        Download the video instead of playing it
      -D, --delete
        Delete history
      -l, --logview
        Show logs
      -s, --syncplay
        Use Syncplay to watch with friends
      -S, --select-nth
        Select nth entry
      -q, --quality
        Specify the video quality (best, worst, or yt-dlp format)
      -v, --vlc
        Use VLC to play the video
      -V, --version
        Show the version of the script
      -h, --help
        Show this help message and exit
      -e, --episode, -r, --range
        Specify the number of episodes to watch
      --rofi
        Use rofi instead of fzf for the interactive menu
      --no-detach
        Don't detach the player (useful for in-terminal playback, mpv only)
      --exit-after-play
        Exit the player, and return the player exit code (useful for non interactive scenarios, mpv only)
      -U, --update
        Update the script

    Note: This fork uses videa.hu as the anime source.
    Videos are played using yt-dlp integration with mpv.

    Some example usages:
      %s -q best banana fish
      %s -d -e 2 cyberpunk edgerunners
      %s --vlc cyberpunk edgerunners -q 1080p -e 4
      %s blue lock -e 5-6
      %s -e \"5 6\" blue lock
    \n" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}"
    exit 0
}

version_info() {
    printf "%s\n" "$version_number"
    exit 0
}

update_script() {
    update="$(curl -s -A "$agent" "https://raw.githubusercontent.com/pystardust/ani-cli/master/ani-cli")" || die "Connection error"
    update="$(printf '%s\n' "$update" | diff -u "$0" -)"
    if [ -z "$update" ]; then
        printf "Script is up to date :)\n"
    else
        if printf '%s\n' "$update" | patch "$0" -; then
            printf "Script has been updated\n"
        else
            die "Can't update for some reason!"
        fi
    fi
    exit 0
}

# checks if dependencies are present
dep_ch() {
    for dep; do
        command -v "${dep%% *}" >/dev/null || die "Program \"${dep%% *}\" not found. Please install it."
    done
}

where_iina() {
    [ -e "/Applications/IINA.app/Contents/MacOS/iina-cli" ] && echo "/Applications/IINA.app/Contents/MacOS/iina-cli" && return 0
    printf "%s" "iina" && return 0
}

where_mpv() {
    command -v "flatpak" >/dev/null && flatpak info io.mpv.Mpv >/dev/null 2>&1 && printf "%s" "flatpak_mpv" && return 0
    printf "%s" "mpv" && return 0
}

# VIDEA.HU HELPER FUNCTIONS

# URL encode special characters
url_encode() {
    printf "%s" "$1" | sed 's/ /%20/g; s/\[/%5B/g; s/\]/%5D/g; s/(/%28/g; s/)/%29/g'
}

# Convert anime name to initials for Witanime search
# "Rurouni Kenshin" -> "RK", "Attack on Titan" -> "AOT"
anime_to_initials() {
    # Convert to uppercase, remove common particles, extract first letter of each word
    printf "%s" "$1" | tr '[:lower:]' '[:upper:]' | \
        sed 's/\<NO\> //g; s/\<WO\> //g; s/\<WA\> //g; s/\<NA\> //g; s/\<NI\> //g; s/\<TO\> //g; s/\<DE\> //g; s/\<GA\> //g; s/\<THE\> //g; s/\<A\> //g; s/\<OF\> //g; s/\<ON\> //g' | \
        sed 's/[^A-Z0-9 ]//g' | tr -s ' ' | \
        sed 's/\([A-Z0-9]\)[^ ]*/\1/g' | tr -d ' '
}

# Parse videa.hu HTML search results
# Extracts: URL\tTITLE (only from known anime uploaders)
parse_videa_results() {
    sed -n 's|.*panel-video-title.*href="\([^"]*\)"[^>]*title="\([^"]*\)".*|\1\t\2|p' | \
    grep -E '^\S+\s+\[(Witanime|Shahiid-anime|Animerco|Animeluxe|Naruto-Kun|YuushaSubs|Judas)'
}

# Check if uploader is a known anime source
is_anime_source() {
    case "$1" in
        Witanime*|Shahiid*|Animerco*|Animeluxe*|Naruto-Kun*|YuushaSubs*|Judas*) return 0 ;;
        *) return 1 ;;
    esac
}

# Score video quality (higher = better)
# Returns: 3=FHD/1080p, 2=HD/720p, 1=SD/480p
quality_score() {
    title="$1"
    case "$title" in
        *FHD*|*1080p*|*1080*) printf "3" ;;
        *HD*|*720p*|*720*)    printf "2" ;;
        *SD*|*480p*|*480*)    printf "1" ;;
        *)                     printf "2" ;; # Default to HD-ish
    esac
}

# Extract anime series name from video title
# "[Witanime com] OP EP 1155 FHD" -> "OP"
# "[Shahiid-anime net] Ao no Miburo S2 - 01 (1080p)" -> "Ao no Miburo S2"
# "[Animerco com] BL S2 EP 21 FHD" -> "BL S2"
# "[Animeluxe com] ..." -> handle similarly
extract_series_name() {
    title="$1"
    # Remove source prefix (various anime uploaders on videa.hu)
    series=$(printf "%s" "$title" | sed 's/^\[[^]]*\] //')
    # Remove episode info and quality
    series=$(printf "%s" "$series" | sed 's/ EP [0-9].*//; s/ - [0-9].*//; s/ ([0-9]*p)$//')
    printf "%s" "$series"
}

# Extract episode number from video title
# "[Witanime com] OP EP 1155 FHD" -> "1155"
# "[Shahiid-anime net] Ao no Miburo S2 - 01 (1080p)" -> "01"
extract_episode_number() {
    title="$1"
    # Try Witanime format: EP XX
    ep=$(printf "%s" "$title" | sed -n 's|.*EP \([0-9]*\).*|\1|p')
    [ -n "$ep" ] && printf "%s" "$ep" && return
    # Try Shahiid format: - XX
    ep=$(printf "%s" "$title" | sed -n 's|.* - \([0-9]*\).*|\1|p')
    [ -n "$ep" ] && printf "%s" "$ep" && return
    printf "0"
}

# Extract source from video title
# "[Witanime com] ..." -> "Witanime"
# "[Shahiid-anime net] ..." -> "Shahiid-anime"
# "[Animerco com] ..." -> "Animerco"
# "[Animeluxe com] ..." -> "Animeluxe"
extract_source() {
    title="$1"
    # Extract text between first [ and first space/]
    source=$(printf "%s" "$title" | sed -n 's/^\[\([^] ]*\).*/\1/p')
    [ -n "$source" ] && printf "%s" "$source" || printf "Unknown"
}

# SCRAPING

# Fetch search results from videa.hu with pagination
fetch_videa_search() {
    query="$1"
    encoded_query=$(url_encode "$query")
    tmp_file=$(mktemp)
    
    # Fetch pages in parallel (default 3 pages = ~60 results)
    page=1
    while [ "$page" -le "$videa_pages" ]; do
        (
            curl -s "${videa_base}/video_kereses/${encoded_query}?page=${page}" -A "$agent" | parse_videa_results
        ) >> "$tmp_file" &
        page=$((page + 1))
    done
    wait
    
    cat "$tmp_file"
    rm -f "$tmp_file"
}

# Search anime on videa.hu using multiple strategies
search_anime() {
    search_term="$1"
    tmp_dir=$(mktemp -d)
    
    # Strategy 1: Direct search (catches all uploaders)
    fetch_videa_search "$search_term" > "$tmp_dir/direct" &
    
    # Strategy 2: Shahiid-anime with full name
    shahiid_query="[Shahiid-anime net] ${search_term}"
    fetch_videa_search "$shahiid_query" > "$tmp_dir/shahiid" &
    
    # Strategy 3: Witanime with initials (if 2+ chars)
    initials=$(anime_to_initials "$search_term")
    if [ ${#initials} -ge 2 ]; then
        witanime_query="[Witanime com] ${initials}"
        fetch_videa_search "$witanime_query" > "$tmp_dir/witanime_initials" &
    fi
    
    wait
    
    # Merge all results, deduplicate by URL, filter empty lines, save to cache file
    cat "$tmp_dir"/* 2>/dev/null | grep -v '^$' | sort -u -t'	' -k1,1 > "$search_cache_file"
    rm -r "$tmp_dir"
    
    [ ! -s "$search_cache_file" ] && return 1
    
    # Group by series and count episodes, merge sources
    # Sort by relevance: exact initials match first, then by episode count
    cat "$search_cache_file" | while IFS='	' read -r url title; do
        [ -z "$url" ] || [ -z "$title" ] && continue
        series=$(extract_series_name "$title")
        [ -z "$series" ] && continue
        source=$(extract_source "$title")
        printf "%s\t%s\n" "$series" "$source"
    done | sort | uniq -c | \
    awk -v initials="$initials" '
    {
        count = $1
        source = $NF
        # Reconstruct series name (everything between count and source)
        series = ""
        for (i = 2; i < NF; i++) {
            series = series (series ? " " : "") $i
        }
        
        # Accumulate sources and counts per series
        if (series in series_sources) {
            if (index(series_sources[series], source) == 0) {
                series_sources[series] = series_sources[series] ", " source
            }
            series_count[series] += count
        } else {
            series_sources[series] = source
            series_count[series] = count
        }
    }
    END {
        for (series in series_count) {
            # Relevance score: 2 = exact initials match, 1 = partial match, 0 = no match
            relevance = 0
            upper_series = toupper(series)
            if (upper_series == initials) relevance = 2
            else if (index(upper_series, initials) > 0) relevance = 1
            printf "%d\t%05d\t%s (%d episodes) [%s]\n", relevance, series_count[series], series, series_count[series], series_sources[series]
        }
    }' | sort -t'	' -k1,1rn -k2,2rn | cut -f3
}

# Get episodes for a specific anime series from cached results
episodes_list() {
    series_pattern="$1"
    [ ! -s "$search_cache_file" ] && return 1
    while IFS='	' read -r url title; do
        series=$(extract_series_name "$title")
        if printf "%s" "$series" | grep -qF "$series_pattern"; then
            ep=$(extract_episode_number "$title")
            printf "%s\n" "$ep"
        fi
    done < "$search_cache_file" | sort -n | uniq
}

# Select best quality video for given series and episode
select_best_video() {
    series_pattern="$1"
    episode="$2"
    quality_pref="$3"
    
    # Pad episode for matching (handle leading zeros)
    ep_padded=$(printf "%02d" "$episode" 2>/dev/null || printf "%s" "$episode")
    ep_plain=$(printf "%d" "$episode" 2>/dev/null || printf "%s" "$episode")
    
    [ ! -s "$search_cache_file" ] && return 1
    
    # Get all matching videos
    matches=$(while IFS='	' read -r url title; do
        series=$(extract_series_name "$title")
        ep=$(extract_episode_number "$title")
        ep_num=$(printf "%d" "$ep" 2>/dev/null || printf "%s" "$ep")
        
        if printf "%s" "$series" | grep -qF "$series_pattern"; then
            if [ "$ep_num" = "$ep_plain" ]; then
                score=$(quality_score "$title")
                printf "%s\t%s\t%s\n" "$score" "$url" "$title"
            fi
        fi
    done < "$search_cache_file")
    
    [ -z "$matches" ] && return 1
    
    # Sort by quality score and pick best (or worst if requested)
    if [ "$quality_pref" = "worst" ]; then
        printf "%s" "$matches" | sort -t'	' -k1,1n | head -1 | cut -f2
    else
        printf "%s" "$matches" | sort -t'	' -k1,1rn | head -1 | cut -f2
    fi
}

# Get episode URL with auto quality selection
get_episode_url() {
    episode=$(select_best_video "$id" "$ep_no" "$quality")
    [ -z "$episode" ] && die "Episode $ep_no not found!"
}

# Quality selection for yt-dlp (simplified)
select_quality() {
    case "$1" in
        best)  ytdl_format="bestvideo+bestaudio/best" ;;
        worst) ytdl_format="worstvideo+worstaudio/worst" ;;
        *)     ytdl_format="$1" ;;
    esac
}

# PLAYING

process_hist_entry() {
    # For videa.hu, id is the series pattern
    # We need to re-search and find next episode
    ep_list=$(episodes_list "$id")
    [ -z "$ep_list" ] && return
    latest_ep=$(printf "%s\n" "$ep_list" | tail -n1)
    ep_count=$(printf "%s\n" "$ep_list" | wc -l | tr -d "[:space:]")
    title=$(printf "%s\n" "$title" | sed "s|[0-9]\+ episodes|${ep_count} episodes|")
    next_ep=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{n;p;}") 2>/dev/null
    [ -n "$next_ep" ] && printf "%s\t%s - episode %s\n" "$id" "$title" "$next_ep"
}

update_history() {
    if grep -q -- "$id" "$histfile" 2>/dev/null; then
        sed -E "s|^[^	]+	${id}	[^	]+$|${ep_no}	${id}	${title}|" "$histfile" >"${histfile}.new"
    else
        cp "$histfile" "${histfile}.new"
        printf "%s\t%s\t%s\n" "$ep_no" "$id" "$title" >>"${histfile}.new"
    fi
    mv "${histfile}.new" "$histfile"
}

download() {
    # Use yt-dlp for all downloads
    yt-dlp -f "$ytdl_format" -o "$download_dir/$2.%(ext)s" "$1"
}

play_episode() {
    [ "$log_episode" = 1 ] && [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && command -v logger >/dev/null && logger -t ani-cli "${anime_title}Episode ${ep_no}"
    [ -z "$episode" ] && get_episode_url
    [ -z "$ytdl_format" ] && select_quality "$quality"
    
    case "$player_function" in
        debug)
            printf "Video URL: %s\nyt-dlp format: %s\n" "$episode" "$ytdl_format"
            ;;
        mpv*)
            if [ "$no_detach" = 0 ]; then
                nohup $player_function --ytdl-format="$ytdl_format" --force-media-title="${anime_title}Episode ${ep_no}" "$episode" >/dev/null 2>&1 &
            else
                $player_function --ytdl-format="$ytdl_format" --force-media-title="${anime_title}Episode ${ep_no}" "$episode"
                mpv_exitcode=$?
                [ "$exit_after_play" = 1 ] && [ -z "$range" ] && exit "$mpv_exitcode"
            fi
            ;;
        android_mpv) nohup am start --user 0 -a android.intent.action.VIEW -d "$episode" -n is.xyz.mpv/.MPVActivity >/dev/null 2>&1 & ;;
        android_vlc) nohup am start --user 0 -a android.intent.action.VIEW -d "$episode" -n org.videolan.vlc/org.videolan.vlc.gui.video.VideoPlayerActivity -e "title" "${anime_title}Episode ${ep_no}" >/dev/null 2>&1 & ;;
        *iina*)
            if pgrep -f "IINA" >/dev/null 2>&1; then
                nohup $player_function --no-stdin --mpv-force-media-title="${anime_title}Episode ${ep_no}" --mpv-ytdl-format="$ytdl_format" "$episode" >/dev/null 2>&1 &
            else
                nohup $player_function --no-stdin --keep-running --mpv-force-media-title="${anime_title}Episode ${ep_no}" --mpv-ytdl-format="$ytdl_format" "$episode" >/dev/null 2>&1 &
            fi
            ;;
        flatpak_mpv) flatpak run io.mpv.Mpv --ytdl-format="$ytdl_format" --force-media-title="${anime_title}Episode ${ep_no}" "$episode" >/dev/null 2>&1 & ;;
        vlc*) nohup $player_function --play-and-exit --meta-title="${anime_title}Episode ${ep_no}" "$episode" >/dev/null 2>&1 & ;;
        *yncpla*) nohup $player_function "$episode" -- --force-media-title="${anime_title}Episode ${ep_no}" --ytdl-format="$ytdl_format" >/dev/null 2>&1 & ;;
        download) "$player_function" "$episode" "${anime_title}Episode ${ep_no}" ;;
        catt) nohup catt cast "$episode" >/dev/null 2>&1 & ;;
        iSH)
            printf "\e]8;;vlc://%s\a~~~~~~~~~~~~~~~~~~~~\n~ Tap to open VLC ~\n~~~~~~~~~~~~~~~~~~~~\e]8;;\a\n" "$episode"
            sleep 5
            ;;
        *) nohup $player_function "$episode" >/dev/null 2>&1 & ;;
    esac
    replay="$episode"
    unset episode
    update_history
    [ "$use_external_menu" = "1" ] && wait
}

play() {
    start=$(printf "%s" "$ep_no" | grep -Eo '^(-1|[0-9]+(\.[0-9]+)?)')
    end=$(printf "%s" "$ep_no" | grep -Eo '(-1|[0-9]+(\.[0-9]+)?)$')
    [ "$start" = "-1" ] && ep_no=$(printf "%s" "$ep_list" | tail -n1) && unset start
    [ -z "$end" ] || [ "$end" = "$start" ] && unset start end
    [ "$end" = "-1" ] && end=$(printf "%s" "$ep_list" | tail -n1)
    line_count=$(printf "%s\n" "$ep_no" | wc -l | tr -d "[:space:]")
    if [ "$line_count" != 1 ] || [ -n "$start" ]; then
        [ -z "$start" ] && start=$(printf "%s\n" "$ep_no" | head -n1)
        [ -z "$end" ] && end=$(printf "%s\n" "$ep_no" | tail -n1)
        range=$(printf "%s\n" "$ep_list" | sed -nE "/^${start}\$/,/^${end}\$/p")
        [ -z "$range" ] && die "Invalid range!"
        for i in $range; do
            tput clear
            ep_no=$i
            printf "\33[2K\r\033[1;34mPlaying episode %s...\033[0m\n" "$ep_no"
            [ "$i" = "$end" ] && unset range
            play_episode
        done
    else
        play_episode
    fi
    # moves up to stored position and deletes to end
    [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && tput rc && tput ed
}

# MAIN

# setup
agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0"
videa_base="https://videa.hu"
videa_pages="${ANI_CLI_VIDEA_PAGES:-3}"
download_dir="${ANI_CLI_DOWNLOAD_DIR:-.}"
log_episode="${ANI_CLI_LOG:-1}"
quality="${ANI_CLI_QUALITY:-best}"
search_cache_file=$(mktemp)
trap 'rm -f "$search_cache_file"' EXIT INT TERM

case "$(uname -a | cut -d " " -f 1,3-)" in
    *Darwin*) player_function="${ANI_CLI_PLAYER:-$(where_iina)}" ;;   # mac OS
    *ndroid*) player_function="${ANI_CLI_PLAYER:-android_mpv}" ;;     # Android OS (termux)
    *MINGW* | *WSL2*) player_function="${ANI_CLI_PLAYER:-mpv.exe}" ;; # Windows OS
    *ish*) player_function="${ANI_CLI_PLAYER:-iSH}" ;;                # iOS (iSH)
    *) player_function="${ANI_CLI_PLAYER:-$(where_mpv)}" ;;           # Linux OS
esac

no_detach="${ANI_CLI_NO_DETACH:-0}"
exit_after_play="${ANI_CLI_EXIT_AFTER_PLAY:-0}"
use_external_menu="${ANI_CLI_EXTERNAL_MENU:-0}"
external_menu_normal_window="${ANI_CLI_EXTERNAL_MENU_NORMAL_WINDOW:-0}"
[ -t 0 ] || use_external_menu=1
hist_dir="${ANI_CLI_HIST_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/ani-cli}"
[ ! -d "$hist_dir" ] && mkdir -p "$hist_dir"
histfile="$hist_dir/ani-hsts"
[ ! -f "$histfile" ] && : >"$histfile"
search="${ANI_CLI_DEFAULT_SOURCE:-scrape}"

while [ $# -gt 0 ]; do
    case "$1" in
        -v | --vlc)
            case "$(uname -a | cut -d " " -f 1,3-)" in
                *ndroid*) player_function="android_vlc" ;;
                MINGW* | *WSL2*) player_function="vlc.exe" ;;
                *ish*) player_function="iSH" ;;
                *) player_function="vlc" ;;
            esac
            ;;
        -s | --syncplay)
            case "$(uname -s)" in
                Darwin*) player_function="/Applications/Syncplay.app/Contents/MacOS/syncplay" ;;
                MINGW* | *Msys)
                    export PATH="$PATH":"/c/Program Files (x86)/Syncplay/"
                    player_function="syncplay.exe"
                    ;;
                *) player_function="syncplay" ;;
            esac
            ;;
        -q | --quality)
            [ $# -lt 2 ] && die "missing argument!"
            quality="$2"
            shift
            ;;
        -S | --select-nth)
            [ $# -lt 2 ] && die "missing argument!"
            index="$2"
            shift
            ;;
        -c | --continue) search=history ;;
        -d | --download)
            [ "$player_function" = "iSH" ] && iSH_DownFix="--async-dns=false"
            player_function=download
            ;;
        -D | --delete)
            : >"$histfile"
            exit 0
            ;;
        -l | --logview)
            case "$(uname -s)" in
                Darwin*) log show --predicate 'process == "logger"' ;;
                Linux*) journalctl -t ani-cli ;;
                *) die "Logger not implemented for your platform" ;;
            esac
            exit 0
            ;;
        -V | --version) version_info ;;
        -h | --help) help_info ;;
        -e | --episode | -r | --range)
            [ $# -lt 2 ] && die "missing argument!"
            ep_no="$2"
            shift
            ;;
        --no-detach) no_detach=1 ;;
        --exit-after-play) exit_after_play=1 && no_detach=1 ;;
        --rofi) use_external_menu=1 ;;
        -U | --update) update_script ;;
        *) query="$(printf "%s" "$query $1" | sed "s|^ ||;s| |+|g")" ;;
    esac
    shift
done
[ "$use_external_menu" = "0" ] && multi_selection_flag="${ANI_CLI_MULTI_SELECTION:-"-m"}"
[ "$use_external_menu" = "1" ] && multi_selection_flag="${ANI_CLI_MULTI_SELECTION:-"-multi-select"}"
[ "$external_menu_normal_window" = "1" ] && external_menu_args="-normal-window"
printf "\33[2K\r\033[1;34mChecking dependencies...\033[0m\n"
dep_ch "curl" "sed" "grep" "yt-dlp" || true
dep_ch "fzf" || true
case "$player_function" in
    debug) ;;
    download) dep_ch "yt-dlp" ;;
    android*) printf "\33[2K\rChecking of players on Android is disabled\n" ;;
    *iSH*) printf "\33[2K\rChecking of players on iOS is disabled\n" ;;
    flatpak_mpv) true ;; # handled out of band in where_mpv
    *) dep_ch "$player_function" ;;
esac

# searching
case "$search" in
    history)
        # For history, we need to re-search to populate cache
        anime_list=""
        while read -r ep_no id title; do
            [ -z "$id" ] && continue
            # Search for this anime to populate cache
            search_anime "$id" >/dev/null 2>&1
            entry=$(process_hist_entry)
            [ -n "$entry" ] && anime_list="${anime_list}${entry}
"
        done <"$histfile"
        [ -z "$anime_list" ] && die "No unwatched series in history!"
        anime_list=$(printf "%s" "$anime_list" | sed '/^$/d')
        [ -z "${index##*[!0-9]*}" ] && result=$(printf "%s" "$anime_list" | nl -w 2 | sed 's/^[[:space:]]//' | nth "Select anime: ")
        [ -z "${index##*[!0-9]*}" ] || result=$(printf "%s" "$anime_list" | sed -n "${index}p")
        [ -z "$result" ] && exit 1
        id=$(printf "%s" "$result" | cut -f1)
        title=$(printf "%s" "$result" | cut -f2 | sed 's/ - episode.*//')
        ep_no=$(printf "%s" "$result" | cut -f2 | sed -nE 's/.*- episode (.+)$/\1/p')
        # Re-populate cache for this anime
        search_anime "$id" >/dev/null 2>&1
        ep_list=$(episodes_list "$id")
        anime_title="$(printf "%s" "$title" | cut -d'(' -f1 | tr -d '[:punct:]') "
        ;;
    *)
        if [ "$use_external_menu" = "0" ]; then
            while [ -z "$query" ]; do
                printf "\33[2K\r\033[1;36mSearch anime: \033[0m" && read -r query
            done
        else
            [ -z "$query" ] && query=$(printf "" | external_menu "" "Search anime: " "$external_menu_args")
            [ -z "$query" ] && exit 1
        fi

        query=$(printf "%s" "$query" | sed "s|+| |g")
        printf "\33[2K\r\033[1;34mSearching videa.hu...\033[0m\n"
        anime_list=$(search_anime "$query")
        [ -z "$anime_list" ] && die "No results found!"
        
        # Format for selection: number, series name
        formatted_list=$(printf "%s\n" "$anime_list" | nl -w 2 | sed 's/^[[:space:]]//')
        
        [ "$index" -eq "$index" ] 2>/dev/null && result=$(printf "%s" "$anime_list" | sed -n "${index}p")
        [ -z "$index" ] && result=$(printf "%s" "$formatted_list" | while read -r num rest; do
            printf "%s\t%s\t%s\n" "$num" "$rest" "$rest"
        done | nth "Select anime: ")
        [ -z "$result" ] && exit 1
        
        # Extract series name (without episode count and sources)
        title="$result"
        id=$(printf "%s" "$result" | sed 's/ ([0-9]* episodes).*//; s/ \[.*\]//')
        anime_title="$(printf "%s" "$id" | tr -d '[:punct:]') "
        
        ep_list=$(episodes_list "$id")
        [ -z "$ep_list" ] && die "No episodes found!"
        
        [ -z "$ep_no" ] && ep_no=$(printf "%s" "$ep_list" | nl -w 2 | sed 's/^[[:space:]]//' | while read -r num ep; do
            printf "%s\t%s\t%s\n" "$num" "$ep" "Episode $ep"
        done | nth "Select episode: " "$multi_selection_flag" | cut -f1)
        [ -z "$ep_no" ] && exit 1
        ;;
esac

# moves the cursor up one line and clears that line
tput cuu1 && tput el
# stores the position of cursor
tput sc

# playback & loop
play
[ "$player_function" = "download" ] || [ "$player_function" = "debug" ] && exit 0

while cmd=$(printf "next\nreplay\nprevious\nselect\nquit" | nth "Playing episode $ep_no of $title... "); do
    case "$cmd" in
        next) ep_no=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{n;p;}") 2>/dev/null ;;
        replay) episode="$replay" ;;
        previous) ep_no=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{g;1!p;};h") 2>/dev/null ;;
        select) ep_no=$(printf "%s" "$ep_list" | nl -w 2 | sed 's/^[[:space:]]//' | while read -r num ep; do
            printf "%s\t%s\t%s\n" "$num" "$ep" "Episode $ep"
        done | nth "Select episode: " "$multi_selection_flag" | cut -f1) ;;
        *) exit 0 ;;
    esac
    [ -z "$ep_no" ] && die "Out of range"
    play
done

# ani-cli
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Project repository: https://github.com/pystardust/ani-cli
